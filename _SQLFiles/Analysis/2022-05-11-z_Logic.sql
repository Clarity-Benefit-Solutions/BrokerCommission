use Broker_Commission
go

select
    "make COMMISSION_RESULT and commission_summary materialzed views";

truncate table dbo.Import_OCT;
go
select
    "convert dtsx import to sql bulk copy and wait till finished. Give error message if error or rows dont match";
select
    "log operation in table using shared DataProcessing lib";

/* UI-1. import file using import raw data using UI */

-- A. It will be saved in "E:\BROKER_COMMISSION_OUTPUT\file_import.csv"
-- B. Sp SP_FILE_IMPORT_SSIS will be run which will run SP_UPLODADFILE
-- ssis proc Broker_Commission will be called
--  step 1 will run local dtsx package on BE015 at "E:\BROKERCOMMISSION\Broker_Commission\BrokerCommissionSSIS\BrokerCommissionSSIS\ImportBrokerCommissionsQBExport.dtsx"
-- C. exec SP_IMPORT_FILE_SENT_SSIS 'MARCH', 2022
--  DELETE FROM  [dbo].[STATEMENT_HEADER] for month & year
-- INSERT INTO [dbo].[STATEMENT_HEADER] select @Month       , @Year      , R.[BROKER_ID]      , R.[BROKER_NAME]      , 0      , R.[TOTAL]      , GETDATE( ) FROM [dbo].[COMMISSION_SUMMARY]
select
    "BUG?: it totals amount for ALL months as it does not restrict query to passed month and date";
-- so statement headers will have one line for each broker to be billed
/* 2. clear sent invoices for dates after the previous month */

/* check Import_OCT - lines should be equal to lines in excel file*/
select *
from
    dbo.Import_OCT
order by
    Import_OCT.Name_FORMATTED
  , Import_OCT.memo_FORMATTED;

/* check STATEMENT_HEADER - should have one row for each broker_id and month*/
select *
from
    dbo.STATEMENT_HEADER
order by
    BROKER_NAME, date;

/* delete all sent invoices that are part of this uplpad for testing ONLY*/
delete
from
    dbo.SENT_INVOICE
where
        INVOICE_NUM in (
                           select
                               Import_OCT.NUM_FORMATTED
                           from
                               dbo.Import_OCT
                           where
                               Date >= '2022-03-01'
                       );

/* UI-2. UI redirects to UploadResults */
--A.   combo fillesd with query
SELECT *
FROM
    [dbo].[COMMISSION_SUMMARY]
Order by
    BROKER_NAME;

--  B. Grid loads with this query - brojker name where is added if a broker is chosen in the drop down
SELECT
    MAX( H.HEADER_ID ) HEADER_ID
  , A.BROKER_ID
  , A.BROKER_NAME
  , A.PAYLOCITY_ID
  , A.TOTAL
FROM
    [dbo].[COMMISSION_SUMMARY] AS A
        LEFT JOIN[dbo].[STATEMENT_HEADER] AS H ON A.BROKER_ID = H.BROKER_ID
WHERE
      1 = 1
  AND A.BROKER_NAME = 'DELUCA PLANNING'
GROUP BY
    A.BROKER_ID
  , A.BROKER_NAME
  , A.PAYLOCITY_ID
  , A.TOTAL
ORDER BY
    A.BROKER_NAME;

--  UI 3: click on statement next to anny broker
-- redirects to http://localhost:59291/ViewFile.aspx?BID=26&MONTH=March&YEAR=2002&StatementID=1633
-- A. raw data grid is bound to :
select *
from
    [dbo].Import_OCT
where
    Agent in ('', '', '');
select
    "could more easily fetch based on passed broker id but perhaps it helps debug ewxactly which rows were selwected based on agent names in master";

-- B. design view  grid is bound to
SELECT *
FROM
    [dbo].[COMMISSION_RESULT]
WHERE
    BROKER_ID = 26
ORDER BY
    QB_CLIENT_NAME;

-- UI 4: click on View/Download Statement
-- directs to code in ViewFile.btn_edit_OnClick
-- 4.A if flag is passed iei report already generated
-- pdf file is fetched from already generated file at using WebClient
/*
  string FilePath = ReportHelper.PDFOutPut
                   + "\\"
                   + model.PAYLOCITY_ID + "_" + model.BROKER_NAME + "_" + Request.QueryString["MONTH"]
                   + "_" + Request.QueryString["YEAR"] + ".pdf";
*/

--  4.B if flag is not passed, a new pdf is generated by calling
-- Report_Helper.CreatedWord_fromResult brokerId
select
    "note this is different than when email statements";
-- 4.B.1 - fetch data from db.STATEMENT_HEADER.Where(x => x.BROKER_ID == brokerID && x.FLAG == 0).FirstOrDefault();
select *
from
    dbo.STATEMENT_HEADER
where
      BROKER_ID = 26
  and FLAG = 0;

--  C. if record is found - we generate a new statement using 2 lists, using open_balance = 0 and not zero
-- C1: ReportHelper.datatable generates list using
SELECT *
FROM
    [dbo].[COMMISSION_RESULT]
WHERE
    BROKER_ID = 26
ORDER BY
    QB_CLIENT_NAME;
--  C2: code creates 2 lists - one for openbalance !=0 and other for openbal = 0
--   var list_paid = list.Where(x => x.HEADER_ID == statementID && x.OPEN_BALANCE == 0).OrderBy(x => x.CLIENT_NAME)
--   var list_pending = list.Where(x => x.HEADER_ID == statementID && x.OPEN_BALANCE != 0).OrderBy(x => x.CLIENT_NAME)

--  C3: code loops thru comm_result rows and splits into paid anmd pending lists
--  it first adds rows to list_paid if open_bal = 0
--  and adds to pdf table 1 and then adds total paid below table
--  it then adds rows to list_pending if open_bal = 0
--  and adds to pdf table 2 and then adds total pending below table

--  C4: pdf is then saved to same pdf file path as above
-- // in testing it goes to -
-- \\fs009\FTP-IT\Broker_Commission\29_DELUCA PLANNING_JANUARY_2022.pdf
-- string savedUrl = PDFOutPut + paylocity_ID + "_" + statement_Header.BROKER_NAME + "_" + statement_Header.MONTH + "_" + statement_Header.YEAR + ".pdf";
select
    "the filename is generated wrongly - it just takes the first date in table for the statement headerid! "
select
    "the totals are wrong as it is just outputting each month which was in the excel file! "

-- UI 5: Button: Email All and Archive
--  calls UploadResults.btn_Approve_Email_OnClick
--  redirects to string url = "SendEmails.aspx?Month=" + lbl_month.Text + "&Year=" + lbl_year.Text;
-- next code is SendEmails.sendEmails
--  5A: EXEC [dbo].[SP_STATEMENT_DETAIL_UPDATE];
/*
1. while there are rows in STATEMENT_HEADER where flag = 0
2.  select top 1 @id = header id  where flag = 0
3. insert rows into
 INSERT INTO [dbo].[STATEMENT_DETAILS]
    FROM
                [dbo].[STATEMENT_HEADER] AS HEADER
                    LEFT JOIN [dbo].[COMMISSION_RESULT] AS R
    ON HEADER.[BROKER_ID] = R.[BROKER_ID]
            WHERE
                  R.[QB_CLIENT_NAME] IS NOT NULL
              AND HEADER.HEADER_ID = @Id
4. update statement_header
 Update [dbo].[STATEMENT_HEADER] Set FLAG = 4  Where HEADER_ID = @Id
 */

-- at the end, all rows in STATEMENT_HEADER will be set to 4
-- all statement_headers brokers which were in 0 are not set to 4 ioe.e. details added to STATEMENT_DETAILS
select
    "how do we ensure no dups get inserted into STATEMENT_DETAILS or STATEMENT_DETAILS or Sent_invoices in case a file is imported more than once ?";

/*
 5B   selects all statement headers where enmail is not send ie.e. flag in (0, 4)
    var list = db.STATEMENT_HEADER.Where(x => x.MONTH == month && x.YEAR == year && x.BROKER_ID != null /*&& ( x.FLAG == 0 || x.FLAG == 4 )*/)
                    .OrderBy(x => x.BROKER_ID).ToList();
*/
select *
from
    dbo.STATEMENT_HEADER
where
      MONTH = 'MARCH'
  and year = 2022
  and BROKER_ID is not null
    /*and FLAG in (0,4)*/
  and BROKER_ID = 26
order by
    STATEMENT_HEADER.BROKER_ID;

-- 5C: for each header
-- 5C1: create pdf
-- string outputPath = ReportHelper.CreatedWord(headerID);

-- 4.B.1 - fetch data from  db.STATEMENT_HEADER.Where(x => x.HEADER_ID == statementID).FirstOrDefault();
select *
from
    dbo.STATEMENT_HEADER
where
      HEADER_ID = 1440
  and FLAG = 0;

--  C. if record is found - we generate a new statement using 2 lists, using open_balance = 0 and not zero
-- C1: ReportHelper.datatable generates list using
SELECT *
FROM
    [dbo].[STATEMENT_DETAILS]
WHERE
    HEADER_ID = 1440
ORDER BY
    QB_CLIENT_NAME;
go
select
    "note this select table is different for statements and uses STATEMENT_DETAILS";
--  C2: code creates 2 lists - one for openbalance !=0 and other for openbal = 0
/*
var list = db.STATEMENT_DETAILS.Where(x => x.HEADER_ID == statementID && x.OPEN_BALANCE == 0).OrderBy(x => x.CLIENT_NAME).ToList();
                var list_pending = db.STATEMENT_DETAILS.Where(x => x.HEADER_ID == statementID && x.OPEN_BALANCE != 0).OrderBy(x => x.CLIENT_NAME).ToList();
*/
--  C3: code loops thru comm_result rows and splits into paid anmd pending lists
--  it first adds rows to list_paid if open_bal = 0
--  and adds to pdf table 1 and then adds total paid below table
--  it then adds rows to list_pending if open_bal = 0
--  and adds to pdf table 2 and then adds total pending below table

--  C4: pdf is then saved to same pdf file path as above
--  if in test mode it goes to
-- string pdfPath_Test = PDFOutPut_Test + paylocity_ID + "_" + statement_Header.BROKER_NAME + "_" + statement_Header.MONTH + "_" + statement_Header.YEAR + ".pdf";
--
--  if NOT test, it goes to
--    string pdfPath = PDFOutPut + paylocity_ID + "_" + statement_Header.BROKER_NAME + "_" + statement_Header.MONTH + "_" + statement_Header.YEAR + ".pdf";
-- // in testing it goes to -

-- \\fs009\FTP-IT\Broker_Commission\29_DELUCA PLANNING_JANUARY_2022.pdf
-- string savedUrl = PDFOutPut + paylocity_ID + "_" + statement_Header.BROKER_NAME + "_" + statement_Header.MONTH + "_" + statement_Header.YEAR + ".pdf";
select
    "the filename is generated wrongly - it just takes the first date in table for the statement headerid! "
select
    "the totals are wrong as it is just outputting each month which was in the excel file! "
select
    "are we supposed to take only the last invoice date for each client?  "

-- 5C2: call util.email_send_with_attachment(from, to, outputPath, item.BROKER_NAME, item.MONTH, item.YEAR);
--  5C3: update header flag to 3 so we will not resned the emaikl
/*

*/
